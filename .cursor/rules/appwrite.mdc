---
description: "Appwrite SDK patterns and best practices for database operations, Cloud Functions, and authentication"
globs: ["services/**/*.ts", "services/appwrite.ts"]
alwaysApply: false
---

# Appwrite Rules

## Client Configuration

All Appwrite services are configured in `services/appwrite.ts`:

```typescript
import { Client, Account, Databases, Storage, Functions } from 'appwrite';

export const account = new Account(client);
export const databases = new Databases(client);
export const storage = new Storage(client);
export const functions = new Functions(client);
```

## Database Operations

### Collection Configuration

Use `APPWRITE_CONFIG` constants for database and collection IDs:

```typescript
import { databases, APPWRITE_CONFIG } from '../appwrite';

const response = await databases.listDocuments({
  databaseId: APPWRITE_CONFIG.DATABASE_ID,
  collectionId: APPWRITE_CONFIG.COLLECTION_PRODUCTS,
  queries: [Query.orderDesc('$createdAt'), Query.limit(100)]
});
```

### Document Structure

- All Appwrite documents use `$id` as the identifier field
- Use `$createdAt` and `$updatedAt` for timestamps
- Map Appwrite documents to TypeScript interfaces

```typescript
// Map Appwrite document to TypeScript interface
const product: Product = {
  $id: doc.$id,
  productName: doc.productName,
  price: doc.price,
  // ... other fields
};
```

### Queries

Use Appwrite Query builder for filtering and sorting:

```typescript
import { Query } from 'appwrite';

// Order by creation date descending
queries: [Query.orderDesc('$createdAt')]

// Filter by status
queries: [Query.equal('status', OrderStatus.COMPLETED)]

// Limit results
queries: [Query.limit(100)]

// Search (client-side filtering for flexibility)
// Note: Appwrite search() requires full-text search indexes
// For flexible matching, fetch all and filter client-side
```

### Error Handling

Wrap all Appwrite operations in try-catch:

```typescript
try {
  const response = await databases.listDocuments({...});
  return { data: response.documents };
} catch (error: any) {
  return { error: error.message || 'Error loading data' };
}
```

## Cloud Functions

### Users Management

User operations go through Cloud Functions for server-side security:

```typescript
import { usersApi } from '../appwrite';

// List users
const response = await usersApi.list();

// Create user
await usersApi.create(userId, email, password, name, role);

// Update user
await usersApi.updateName(userId, name);
await usersApi.updateStatus(userId, true);
await usersApi.updateLabels(userId, [UserRole.ADMIN]);
```

### Function Execution Pattern

```typescript
async callFunction(functionId: string, data: any) {
  const response = await functions.createExecution(functionId, JSON.stringify(data));
  const result = JSON.parse(response.responseBody || '{}');
  if (result.error) {
    throw new Error(result.error);
  }
  return result.data;
}
```

## Authentication

### Account Operations

```typescript
import { account } from '../appwrite';

// Create session
await account.createEmailPasswordSession({ email, password });

// Get current user
const user = await account.get();

// Delete session
await account.deleteSession({ sessionId: 'current' });
```

## Storage

### File Operations

```typescript
import { storage, APPWRITE_CONFIG } from '../appwrite';

// Upload file
const file = await storage.createFile({
  bucketId: APPWRITE_CONFIG.BUCKET_MEDIA,
  fileId: ID.unique(),
  file: fileInput
});

// Get file URL
const url = storage.getFileView({
  bucketId: APPWRITE_CONFIG.BUCKET_MEDIA,
  fileId: file.$id
});
```

## Analytics Collection

The `analytics_events` collection tracks user interactions:

- **type** (string, required): Event type ('page_view', 'product_view', 'user_action')
- **userId** (string, optional): User ID for authenticated users
- **productId** (string, optional): Product ID for product-specific events
- **$createdAt**: Auto-generated timestamp

Use `Promise.allSettled()` for analytics queries to handle missing collections gracefully:

```typescript
const [eventsResponse] = await Promise.allSettled([
  databases.listDocuments({
    databaseId: APPWRITE_CONFIG.DATABASE_ID,
    collectionId: APPWRITE_CONFIG.COLLECTION_ANALYTICS_EVENTS,
    queries: [Query.limit(10000)]
  })
]);

const events = eventsResponse.status === 'fulfilled' 
  ? eventsResponse.value.documents 
  : [];
```

## Best Practices

1. **Always use APPWRITE_CONFIG constants** - Never hardcode database/collection IDs
2. **Handle errors gracefully** - Return user-friendly error messages in Hebrew
3. **Type safety** - Map Appwrite documents to TypeScript interfaces
4. **Client-side filtering** - For flexible search, fetch and filter client-side
5. **Parallel queries** - Use `Promise.allSettled()` for independent operations (handles missing collections)
6. **Cloud Functions** - Use for sensitive operations (user management, admin tasks)
7. **Analytics aggregation** - Compute metrics client-side for small datasets; move to Cloud Functions for scale

## RTK Query Integration

Appwrite operations should be wrapped in RTK Query endpoints:

```typescript
getProducts: builder.query<Product[], void>({
  queryFn: async () => {
    try {
      const response = await databases.listDocuments({
        databaseId: APPWRITE_CONFIG.DATABASE_ID,
        collectionId: APPWRITE_CONFIG.COLLECTION_PRODUCTS,
        queries: [Query.orderDesc('$createdAt')]
      });
      return { data: response.documents as Product[] };
    } catch (error: any) {
      return { error: error.message };
    }
  },
  providesTags: ['Products'],
}),
```

@services/appwrite.ts
@services/api/*.ts
