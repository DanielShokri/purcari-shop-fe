# Hebrew Admin Dashboard - Cursor Rules

## Project Overview

This is a Hebrew RTL (right-to-left) admin dashboard built with React 19 and TypeScript. The application is an admin-only e-commerce management system with products, orders, users, categories, coupons, and analytics features. Only users with the `admin` label in Appwrite can access this panel.

## Technology Stack

- **Framework**: React 19 with TypeScript
- **Build Tool**: Vite 6
- **UI Library**: Chakra UI v3 with Emotion
- **State Management**: Redux Toolkit with RTK Query
- **Routing**: React Router DOM v7 (HashRouter)
- **Forms**: React Hook Form
- **Backend**: Appwrite SDK (Cloud)
- **Charts**: Recharts

## Environment Configuration

- Use Vite environment variables with `VITE_` prefix
- Access via `import.meta.env.VITE_VARIABLE_NAME`
- Store in `.env.local` (gitignored), template in `.env.example`
- Required variables: `VITE_APPWRITE_ENDPOINT`, `VITE_APPWRITE_PROJECT_ID`

## Code Style & Conventions

### TypeScript

- Use TypeScript for all files (`.ts`, `.tsx`)
- Target ES2022 with ESNext modules
- Use `@/*` path alias for imports (maps to project root)
- Prefer interfaces over types for object shapes
- Use enums for finite sets of values (e.g., `OrderStatus`, `UserRole`)
- Use `Partial<T>` for mutation/update inputs
- Appwrite documents use `$id` as the identifier field

```typescript
// Good: Interface with Appwrite convention
export interface Product {
  $id: string;
  productName: string;
  price: number;
}

// Good: Enum for status values
export enum OrderStatus {
  PENDING = 'pending',
  PROCESSING = 'processing',
  COMPLETED = 'completed',
  CANCELLED = 'cancelled'
}
```

### Component Patterns

- Use functional components with `export default function ComponentName()`
- Define props inline for simple components: `{ prop }: { prop: Type }`
- Co-locate small sub-components in the same file (e.g., `StatCard`, modals)
- Use React.ReactNode for children props
- Import React explicitly: `import React from 'react'`

```typescript
// Good: Default export with inline props
export default function Layout({ children }: { children?: React.ReactNode }) {
  return <div>{children}</div>;
}

// Good: Local sub-component in same file
const StatCard = ({ title, value, color }: { title: string; value: string; color: string }) => (
  <Card.Root>...</Card.Root>
);
```

### State Management (Redux Toolkit)

- Use RTK Query for all API calls with `createApi` and `fakeBaseQuery()`
- Define slices with `createSlice` and typed `PayloadAction`
- Export typed hooks: `RootState`, `AppDispatch`
- Use tag-based cache invalidation (`tagTypes`, `providesTags`, `invalidatesTags`)
- Wrap localStorage access in safe try-catch helpers (silent fail)

```typescript
// Good: RTK Query endpoint pattern
getProducts: builder.query({
  queryFn: async () => {
    try {
      // API call logic
      return { data: products };
    } catch (error: any) {
      return { error: error.message };
    }
  },
  providesTags: ['Products'],
}),

// Good: Mutation with invalidation
createProduct: builder.mutation({
  queryFn: async (newProduct: Partial<Product>) => {
    // Create logic
    return { data: product };
  },
  invalidatesTags: ['Products'],
}),
```

### Forms (React Hook Form)

- Use `useForm` hook with TypeScript generics
- Destructure `register`, `handleSubmit`, `formState: { errors }`
- Use `{...register('fieldName', { required: true })}` pattern
- Display validation errors conditionally

```typescript
const { register, handleSubmit, formState: { errors } } = useForm<Partial<Product>>();

<Input {...register('productName', { required: 'שדה חובה' })} />
{errors.productName && <Field.ErrorText>{errors.productName.message}</Field.ErrorText>}
```

### Routing

- Use `HashRouter` for deployment compatibility
- Implement `ProtectedRoute` wrapper for authenticated routes
- Use `useNavigate`, `useLocation` hooks
- Redirect unauthenticated users to `/login`
- Admin label check on login and session restore

### RTL (Right-to-Left) Considerations

- HTML has `lang="he" dir="rtl"` set
- Use Inter font family for UI text
- Tables use `text-right` alignment
- For LTR content (dates, code), use `dir="ltr"` attribute
- Sidebar is positioned on the right side

```typescript
// LTR override for specific content
<Input dir="ltr" type="email" />
<Text dir="ltr">{new Date(date).toLocaleDateString('he-IL')}</Text>

// Chart container needs LTR
<Box style={{ direction: 'ltr' }}>
  <ResponsiveContainer>...</ResponsiveContainer>
</Box>
```

### Hebrew Text Guidelines

- Use Hebrew for all UI labels and messages
- Error messages in Hebrew: `'שם משתמש או סיסמה שגויים'`
- Loading states: `'טוען נתונים...'`, `'טוען מוצרים...'`
- Confirmation dialogs: `'האם אתה בטוח שברצונך למחוק?'`
- Button text: `'התחבר'`, `'שמור'`, `'ביטול'`, `'מחק'`, `'ערוך'`

## File Organization

```
/
├── App.tsx                  # Main app with routes
├── index.tsx                # Entry point with providers
├── index.html               # HTML template
├── store.ts                 # Redux store configuration
├── theme.ts                 # Chakra UI custom theme
├── vite-env.d.ts            # TypeScript env declarations
├── types/                   # Domain-specific type definitions
│   ├── index.ts             # Re-exports all types
│   ├── auth.types.ts        # Auth/User types (AuthUser, User, UserRole, UserStatus)
│   ├── products.types.ts    # Product/Category types
│   ├── orders.types.ts      # Order types (Order, OrderDetails, OrderItem)
│   ├── analytics.types.ts   # Analytics types
│   ├── notifications.types.ts # Notification types
│   ├── coupons.types.ts     # Coupon types
│   └── common.types.ts      # Shared types (StatCardProps)
├── components/
│   ├── ui/                  # Chakra provider & utilities
│   ├── shared/              # Reusable components (Pagination, StatusBadge, etc.)
│   ├── layout-parts/        # Layout components (Header, Sidebar)
│   ├── products/            # Product-specific components
│   ├── orders/              # Order-specific components
│   ├── users/               # User-specific components
│   ├── categories/          # Category-specific components
│   ├── coupons/             # Coupon-specific components
│   ├── analytics/           # Analytics chart components
│   ├── notifications/       # Notification components
│   ├── search/              # Global search components
│   ├── post-editor/         # Editor form components
│   └── dashboard/           # Dashboard widgets
├── pages/                   # Page components
├── services/
│   ├── appwrite.ts          # Appwrite client configuration
│   └── api/                 # RTK Query API slices by domain
│       ├── baseApi.ts       # RTK Query base API
│       ├── authApi.ts       # Authentication endpoints (admin-only)
│       ├── productsApi.ts   # Products CRUD
│       ├── ordersApi.ts     # Orders CRUD
│       ├── usersApi.ts      # Users management (via Cloud Function)
│       ├── categoriesApi.ts # Categories CRUD
│       ├── couponsApi.ts    # Coupons CRUD
│       ├── analyticsApi.ts  # Analytics endpoints
│       ├── notificationsApi.ts # Notifications
│       ├── dashboardApi.ts  # Dashboard data
│       └── searchApi.ts     # Global search
├── functions/               # Appwrite Cloud Functions
│   └── users-management/    # Server-side user management
└── contexts/                # React contexts
```

### Naming Conventions

- **Files**: PascalCase for components (`Dashboard.tsx`), camelCase for utilities (`api.ts`)
- **Type Files**: `*.types.ts` suffix for type definition files
- **Components**: PascalCase (`StatCard`, `ProductEditor`)
- **Functions**: camelCase (`handleSubmit`, `getStatusBadge`)
- **Constants**: SCREAMING_SNAKE_CASE for config (`APPWRITE_CONFIG`)
- **Hooks**: camelCase with `use` prefix (RTK Query auto-generates: `useGetProductsQuery`)

## Icons

- Use Material Symbols Outlined via Google Fonts CDN
- Reference with className: `className="material-symbols-outlined"`

```typescript
<Text as="span" className="material-symbols-outlined" fontSize="20px">
  shopping_cart
</Text>
```

## Error Handling

- Wrap API calls in try-catch blocks
- Return `{ error: error.message }` from RTK Query endpoints
- Display user-friendly Hebrew error messages
- Silent fail for non-critical errors (e.g., localStorage access)
- No console.log/error/warn in production code

## Authentication Flow

1. User enters credentials on `/login`
2. Create Appwrite session with `account.createEmailPasswordSession()`
3. Verify user has `admin` label via Cloud Function
4. If not admin, destroy session and show error
5. On success, dispatch `setCredentials` with user data
6. Cache user data in localStorage (for quick UI access)
7. On logout, dispatch `logoutUser` and clear session

## Security Guidelines

- Environment variables for all sensitive config
- Admin-only access enforced on login AND session restore
- No self-registration (admins created via Appwrite Console)
- No console statements in production code
- Appwrite handles session management via cookies

## Anti-Patterns to Avoid

- Don't use class components
- Don't use `any` type without explicit need
- Don't hardcode credentials or API endpoints
- Don't use console.log/error/warn (silent fail or error state)
- Don't create separate files for tiny sub-components
- Don't forget RTL considerations when adding new UI elements
- Don't allow non-admin users to access the panel
