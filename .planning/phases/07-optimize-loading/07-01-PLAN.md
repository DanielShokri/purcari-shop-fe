---
phase: 07-optimize-loading
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/admin/hooks/useCachedQuery.ts
  - apps/admin/hooks/useEntityList.ts
  - apps/admin/hooks/useOrders.ts
  - apps/admin/hooks/useUsers.ts
  - apps/admin/hooks/useCategories.ts
autonomous: true
requirements: []
must_haves:
  truths:
    - "First visit to a page shows loading spinner (cold cache)"
    - "Returning to a page shows data immediately (warm cache) without full spinner"
    - "Background refresh shows subtle indicator instead of blocking spinner"
  artifacts:
    - path: "apps/admin/hooks/useCachedQuery.ts"
      provides: "Smart loading hook with cache detection"
      exports: ["useCachedQuery", "UseCachedQueryReturn"]
    - path: "apps/admin/hooks/useEntityList.ts"
      provides: "Updated entity list with cached loading"
      adds: ["hasEverLoaded", "isRefreshing"]
    - path: "apps/admin/hooks/useOrders.ts"
      provides: "Updated orders hook with cached loading"
      adds: ["hasEverLoaded", "isRefreshing"]
    - path: "apps/admin/hooks/useUsers.ts"
      provides: "Updated users hook with cached loading"
      adds: ["hasEverLoaded", "isRefreshing"]
    - path: "apps/admin/hooks/useCategories.ts"
      provides: "Updated categories hook with cached loading"
      adds: ["hasEverLoaded", "isRefreshing"]
  key_links:
    - from: "useCachedQuery.ts"
      to: "useEntityList.ts"
      via: "import and use pattern"
    - from: "useCachedQuery.ts"
      to: "useOrders.ts"
      via: "import and use pattern"
    - from: "useCachedQuery.ts"
      to: "useUsers.ts"
      via: "import and use pattern"
---

<objective>
Create smart loading hooks that track cache state to eliminate unnecessary spinners on page navigation.

Purpose: Users should only see loading spinner on FIRST visit to a page. Returning to previously viewed pages should show data instantly from cache.

Output: New useCachedQuery hook + updated existing hooks
</objective>

<execution_context>
@/Users/danielshmuel.mirshukri/.config/opencode/get-shit-done/workflows/execute-plan.md
</execution_context>

<context>
@apps/admin/hooks/useEntityList.ts
@apps/admin/hooks/useOrders.ts
@apps/admin/hooks/useUsers.ts
@apps/admin/hooks/useCategories.ts
@apps/admin/components/shared/LoadingState.tsx

Key insight: Convex useQuery returns undefined while loading, but cached data is available instantly from previous visits.
</context>

<tasks>

<task type="auto">
  <name>Create useCachedQuery hook with cache detection</name>
  <files>apps/admin/hooks/useCachedQuery.ts</files>
  <action>
    Create a new hook that wraps useQuery and tracks whether data has ever been loaded.

    The hook should export:
    ```typescript
    interface UseCachedQueryReturn<T> {
      data: T | undefined;
      isLoading: boolean;        // True only on first load (cold cache)
      hasEverLoaded: boolean;   // True after first successful load
      isRefreshing: boolean;    // True when fetching but data exists
    }
    ```

    Implementation approach:
    - Use useRef to track if data has ever been loaded
    - Use useState to track the previous data value
    - Compare current data with previous to detect "refreshing" vs "first load"
    - On first mount: isLoading = true only if data === undefined AND !hasEverLoaded
    - After data loads: mark hasEverLoaded = true

    This pattern leverages Convex's built-in caching - data is available instantly from cache on subsequent visits.
  </action>
  <verify>
    File exists at apps/admin/hooks/useCachedQuery.ts with correct exports
    Hook can be imported and used in other hooks
  </verify>
  <done>
    New hook created that can detect cold vs warm cache
  </done>
</task>

<task type="auto">
  <name>Update useEntityList to track cache state</name>
  <files>apps/admin/hooks/useEntityList.ts</files>
  <action>
    Modify useEntityList to use the new caching pattern:

    1. Import useCachedQuery from './useCachedQuery'
    2. Replace direct useQuery call with useCachedQuery wrapper
    3. Export hasEverLoaded and isRefreshing in the return object

    Keep the same API for backward compatibility - just add new fields:
    - Add hasEverLoaded: boolean to UseEntityListReturn
    - Add isRefreshing: boolean to UseEntityListReturn

    The internal logic stays the same, but the loading detection becomes smarter.
  </action>
  <verify>
    useEntityList now returns hasEverLoaded and isRefreshing
    Products.tsx, Coupons.tsx, CartRules.tsx still work
  </verify>
  <done>
    useEntityList updated with cache-aware loading states
  </done>
</task>

<task type="auto">
  <name>Update useOrders to track cache state</name>
  <files>apps/admin/hooks/useOrders.ts</files>
  <action>
    Modify useOrders to track cache state:

    1. Add internal state for tracking: const [hasEverLoaded, setHasEverLoaded] = useState(false)
    2. Track when data first loads: useEffect(() => { if (orders !== undefined && !hasEverLoaded) setHasEverLoaded(true) }, [orders])
    3. Update isLoading logic: const isLoading = !hasEverLoaded && orders === undefined
    4. Add isRefreshing: boolean - true when orders !== undefined but we're refetching (use Convex's query handle)

    Export hasEverLoaded and isRefreshing in UseOrdersReturn
  </action>
  <verify>
    useOrders now returns hasEverLoaded and isRefreshing
    Orders.tsx still works
  </verify>
  <done>
    useOrders updated with cache-aware loading states
  </done>
</task>

<task type="auto">
  <name>Update useUsers to track cache state</name>
  <files>apps/admin/hooks/useUsers.ts</files>
  <action>
    Same pattern as useOrders:

    1. Add const [hasEverLoaded, setHasEverLoaded] = useState(false)
    2. Track first load with useEffect
    3. Update isLoading: const isLoading = !hasEverLoaded && users === undefined
    4. Add isRefreshing boolean
    5. Export hasEverLoaded and isRefreshing
  </action>
  <verify>
    useUsers now returns hasEverLoaded and isRefreshing
    Users.tsx still works
  </verify>
  <done>
    useUsers updated with cache-aware loading states
  </done>
</task>

<task type="auto">
  <name>Update useCategories to track cache state</name>
  <files>apps/admin/hooks/useCategories.ts</files>
  <action>
    Same pattern as useOrders:

    1. Add const [hasEverLoaded, setHasEverLoaded] = useState(false)
    2. Track first load with useEffect
    3. Update isLoading: const isLoading = !hasEverLoaded && categories === undefined
    4. Add isRefreshing boolean
    5. Export hasEverLoaded and isRefreshing
  </action>
  <verify>
    useCategories now returns hasEverLoaded and isRefreshing
    Categories.tsx still works
  </verify>
  <done>
    useCategories updated with cache-aware loading states
  </done>
</task>

</tasks>

<verification>
Run admin app and navigate between pages:
1. First visit to Products: shows spinner (cold)
2. Navigate to Orders: shows spinner (cold for Orders)
3. Navigate back to Products: should show data INSTANTLY without spinner (warm cache)
</verification>

<success_criteria>
- [x] New useCachedQuery hook created
- [x] useEntityList returns hasEverLoaded and isRefreshing
- [x] useOrders returns hasEverLoaded and isRefreshing
- [x] useUsers returns hasEverLoaded and isRefreshing
- [x] useCategories returns hasEverLoaded and isRefreshing
- [x] Returning to previously visited page shows data without full spinner
</success_criteria>

<output>
After completion, create `.planning/phases/07-optimize-loading/07-01-SUMMARY.md`
</output>
