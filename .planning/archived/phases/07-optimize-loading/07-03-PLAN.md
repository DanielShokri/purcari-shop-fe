---
phase: 07-optimize-loading
plan: 03
type: execute
wave: 3
depends_on: ["07-02"]
files_modified:
  - apps/admin/pages/Dashboard.tsx
  - apps/admin/pages/Analytics.tsx
  - apps/admin/pages/OrderDetails.tsx
  - apps/admin/pages/ProductEditor.tsx
autonomous: true
requirements: []
must_haves:
  truths:
    - "Dashboard shows data instantly on return visits"
    - "Analytics shows data instantly on return visits"
    - "Detail pages (OrderDetails, ProductEditor) show data instantly when data is cached"
  artifacts:
    - path: "apps/admin/pages/Dashboard.tsx"
      provides: "Updated with cache-aware loading"
      changes: ["track hasEverLoaded for all 5 queries"]
    - path: "apps/admin/pages/Analytics.tsx"
      provides: "Updated with cache-aware loading"
      changes: ["track hasEverLoaded for queries"]
    - path: "apps/admin/pages/OrderDetails.tsx"
      provides: "Updated with cache-aware loading"
      changes: ["track hasEverLoaded for order query"]
    - path: "apps/admin/pages/ProductEditor.tsx"
      provides: "Updated with cache-aware loading"
      changes: ["track hasEverLoaded for product query"]
  key_links:
    - from: "Dashboard.tsx"
      to: "api.admin.getStats"
      via: "useQuery"
    - from: "OrderDetails.tsx"
      to: "api.orders.getById"
      via: "useQuery"
---

<objective>
Update Dashboard, Analytics, and detail pages with cache-aware loading.

Purpose: These pages have multiple queries - apply same pattern to eliminate unnecessary spinners.

Output: Updated pages with smart loading behavior
</objective>

<execution_context>
@/Users/danielshmuel.mirshukri/.config/opencode/get-shit-done/workflows/execute-plan.md
</execution_context>

<context>
@apps/admin/pages/Dashboard.tsx
@apps/admin/pages/Analytics.tsx
@apps/admin/pages/OrderDetails.tsx
@apps/admin/pages/ProductEditor.tsx

These pages use multiple useQuery calls directly, not through hooks.
Need to apply the same hasEverLoaded pattern to each query.
</context>

<tasks>

<task type="auto">
  <name>Update Dashboard with cache-aware loading</name>
  <files>apps/admin/pages/Dashboard.tsx</files>
  <action>
    Dashboard has 5 queries:
    - api.admin.getStats
    - api.orders.listAll
    - api.admin.getAvailableYears
    - api.admin.getMonthlySales
    - api.activities.getLatest

    Pattern for each query:
    ```typescript
    // Track individual query states
    const [statsLoaded, setStatsLoaded] = useState(false);
    const stats = useQuery(api.admin.getStats);
    useEffect(() => { if (stats !== undefined) setStatsLoaded(true) }, [stats]);

    // ... repeat for each query ...
    ```

    Then change loading check from:
    ```typescript
    const isLoading = stats === undefined || recentOrders === undefined || ...;
    ```

    To:
    ```typescript
    const hasData = stats !== undefined || statsLoaded; // Show if loaded OR has cached
    const isLoading = !hasData; // Only loading if never loaded AND no data
    ```

    Actually simpler: track overall "hasEverLoaded" as combination:
    ```typescript
    const [hasEverLoaded, setHasEverLoaded] = useState(false);
    const allLoaded = stats !== undefined && recentOrders !== undefined && ...;

    useEffect(() => {
      if (allLoaded) setHasEverLoaded(true);
    }, [allLoaded]);

    const isLoading = !hasEverLoaded && !allLoaded;
    ```
  </action>
  <verify>
    Navigate Dashboard → Products → Dashboard - should show data instantly
  </verify>
  <done>
    Dashboard uses cache-aware loading
  </done>
</task>

<task type="auto">
  <name>Update Analytics with cache-aware loading</name>
  <files>apps/admin/pages/Analytics.tsx</files>
  <action>
    Same pattern as Dashboard - track hasEverLoaded for all queries.

    Check Analytics.tsx for the queries it uses and apply the same pattern.
  </action>
  <verify>
    Navigate Analytics → Products → Analytics - should show data instantly
  </verify>
  <done>
    Analytics uses cache-aware loading
  </done>
</task>

<task type="auto">
  <name>Update OrderDetails with cache-aware loading</name>
  <files>apps/admin/pages/OrderDetails.tsx</files>
  <action>
    OrderDetails uses useParams to get order ID, then fetches single order.

    Since it's a detail page (visiting specific order), apply same pattern:
    - Track hasEverLoaded
    - Only show spinner on first load
  </action>
  <verify>
    Open order #123 → go back → open order #123 - should show instantly
  </verify>
  <done>
    OrderDetails uses cache-aware loading
  </done>
</task>

<task type="auto">
  <name>Update ProductEditor with cache-aware loading</name>
  <files>apps/admin/pages/ProductEditor.tsx</files>
  <action>
    ProductEditor loads product data for editing.

    Apply same pattern - track hasEverLoaded, only show spinner on first load.
  </action>
  <verify>
    Edit product → go back → edit same product - should load faster
  </verify>
  <done>
    ProductEditor uses cache-aware loading
  </done>
</task>

</tasks>

<verification>
Full test:
1. First visit to Dashboard: shows spinner
2. Navigate Products → Dashboard: shows data instantly
3. First visit to Analytics: shows spinner  
4. Navigate Products → Analytics: shows data instantly
5. Visit order details → back → same order: shows faster
</verification>

<success_criteria>
- [x] Dashboard shows data instantly on return visits
- [x] Analytics shows data instantly on return visits
- [x] OrderDetails loads faster on repeat visits
- [x] ProductEditor loads faster on repeat visits
- [x] First visits still show appropriate loading states
</success_criteria>

<output>
After completion, create `.planning/phases/07-optimize-loading/07-03-SUMMARY.md`
</output>
